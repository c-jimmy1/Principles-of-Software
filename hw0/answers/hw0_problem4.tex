\documentclass[11pt]{article}
\usepackage[shortlabels]{enumitem}
\usepackage[margin=1in,headheight=15pt]{geometry}   % Adjusted headheight
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{cancel}
\usepackage{amsfonts}
\usepackage{setspace}

% Set up fancy header/footer
\pagestyle{fancy}
\fancyhead[LO,L]{Jimmy Chen}
\fancyhead[CO,C]{CSCI 2600 - Principles of Software}
\fancyhead[RO,R]{November 13, 2023}
\fancyfoot[LO,L]{}
\fancyfoot[CO,C]{\thepage}
\fancyfoot[RO,R]{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\onehalfspacing

\begin{document}
\section{Problem 4}

\subsection{What is wrong with Ball.java?}
\textbf{Answer:}
The issue with Ball was that it was being assigned to itself, i.e., volume = volume and color = color. 
In order to fix this, you have to assign it to the current object, which would be this.volume = volume and this.color = color.
The other issues I found was that the getVolume and getColor methods were returning nothing, so I changed it to return the volume and color respectively.

\subsection{Which approach do you think is the better one? Why?}
\textbf{Answer:}
I believe that option 2 (Keep track of the total volume of the Balls in BallContainer whenever Balls are added and removed)
is the better one, as it would work faster for larger amounts of total volume. There is less repetitive computations being made, and it would be easier to keep track of the total volume.

\subsection{There are many ways to implement getBallsFromSmallest(). Briefly describe at
least two different ways. Your answers should differ in the implementation of Box,
not in lower-level implementation (for example, using an insertion sort instead of
a selection sort is a lower-level implementation because it does not affect how Box
is implemented). Hint: think about different places in the Box class where you
could add code to achieve the desired functionality. \\Which of the above ways do you think is the best? Why?}
\textbf{Answer:}
To implement getBallsFromSmallest(), one approach is to enhance the BallContainer class by maintaining a sorted collection of balls using the same comparator. Subsequently, we can optimize the function to return an iterator for this stored collection.
\\Another way could involve creating a priority queue (min-heap) within the Box class. You can insert all the balls into the priority queue, where the priority is determined by the size of the balls. Then, you can repeatedly extract the smallest element from the priority queue and output it. This way, you achieve a similar result without explicitly sorting the balls.
\\The sorted one might be better if you need more access to all different sizes of balls, but the priority queue might be better if you only need the smallest ball. In my opinion, I feel like
the first approach it better because it is more flexible and can be used for more purposes.
\end{document}  